# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UsdSG_Fo-GbxPtgZ2KjqM-ZjY8aPtc7D
"""

import yfinance as yf
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

# List of cryptocurrency tickers on Yahoo Finance
cryptos = ['BTC-USD', 'ETH-USD', 'XRP-USD', 'BNB-USD', 'SOL-USD', 'ADA-USD', 'DOGE-USD', 'TRX-USD']
crypto_names = ['Bitcoin', 'Ethereum', 'XRP', 'Binance Coin', 'Solana', 'Cardano', 'Dogecoin', 'TRON']

def fetch_data(ticker, days=700, interval="1h"):
    data = yf.download(ticker, period=f"{days}d", interval=interval)
    prices = data[['Close']].rename(columns={'Close': ticker})

    # Fetch market cap using the info attribute
    ticker_info = yf.Ticker(ticker).info
    market_cap = ticker_info.get('marketCap')  # Get market cap from info

    # Add market cap as a new column
    prices['MarketCap_' + ticker] = market_cap

    return prices

# Fetch price data and market cap for each cryptocurrency with hourly interval
price_data = {}
for crypto in cryptos:
    price_data[crypto] = fetch_data(crypto)

# Merge all price data and market cap into a single DataFrame
df = pd.concat(price_data.values(), axis=1)

# Function to plot correlation matrix as a heatmap

# Get the start and end dates for each week
weekly_dates = df.resample('W').last().index

# Calculate weekly correlations using daily data
# Calculate weekly correlations using daily data, excluding market cap columns
weekly_correlations = []
for i in range(len(weekly_dates) - 1):
    start_date = weekly_dates[i]
    end_date = weekly_dates[i + 1]

    # Filter data for the current week
    week_data = df[(df.index >= start_date) & (df.index < end_date)]

    # Select only price columns for correlation calculation
    price_columns = [col for col in week_data.columns if not col[0].startswith('MarketCap_')]
    week_data_prices = week_data[price_columns]

    # Calculate returns for the week
    week_returns = week_data_prices.pct_change().dropna()

    # Check if week_returns is empty before calculating correlation
    if not week_returns.empty:
        weekly_corr = week_returns.corr()
        weekly_corr.columns = [col.replace('-USD', '') for col in weekly_corr.columns.get_level_values(0)]
        weekly_corr.index = [col.replace('-USD', '') for col in weekly_corr.index.get_level_values(0)]
        weekly_correlations.append(weekly_corr)
    else:
        print(f"Warning: No data available for week {i + 1}. Skipping correlation calculation.")

def plot_correlation_heatmap(corr_matrix, week_number, start_date, end_date,vmin=None, vmax=None):
    plt.figure(figsize=(10, 8))
    sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', fmt=".2f",
                xticklabels=corr_matrix.columns, yticklabels=corr_matrix.columns,vmin=vmin, vmax=vmax)
    plt.title(f'Correlation Matrix for Week {week_number} ({start_date} - {end_date})')
    plt.show()

all_correlations = [corr.values.flatten() for corr in weekly_correlations]
all_correlations = np.concatenate(all_correlations)
vmin = np.nanmin(all_correlations)
vmax = np.nanmax(all_correlations)

# Loop through each week and plot with fixed scale
for i, week_corr in enumerate(weekly_correlations):
    start_date_str = weekly_dates[i].strftime('%Y-%m-%d')
    end_date_str = weekly_dates[i + 1].strftime('%Y-%m-%d')
    plot_correlation_heatmap(week_corr, i + 1, start_date_str, end_date_str, vmin, vmax)

best_pairs=[]
for i, week_corr in enumerate(weekly_correlations):
    start_date_str = weekly_dates[i].strftime('%Y-%m-%d')
    end_date_str = weekly_dates[i + 1].strftime('%Y-%m-%d')
    min_value=1000
    min_coins=(None,None)
    print(f"Week {i + 1} ({start_date_str} - {end_date_str}):")

    for coin in week_corr.columns:
        market_cap_col = 'MarketCap_' + coin + '-USD'  # Construct market cap column name
        market_cap = df.loc[weekly_dates[i], market_cap_col]  # Get market cap for the coin

        for other_coin in week_corr.columns:
            market_cap_col2 = 'MarketCap_' + other_coin + '-USD'  # Construct market cap column name
            market_cap2 = df.loc[weekly_dates[i], market_cap_col2]  # Get market cap for the coin
            if coin != other_coin:
                corr = week_corr.loc[coin, other_coin]
                value = np.abs( 1 / (np.log(market_cap.iloc[0]+market_cap2.iloc[0]) * corr) if corr != 0 else np.inf)  # Handle zero correlation
                if value < min_value and corr>0:
                    min_value = value
                    min_coins=(coin,other_coin)
    best_pairs.append({'pair': min_coins, 'value': min_value}) # Indented this line to align with the outer for loop

print(best_pairs)

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

def calculate_impermanent_loss(price1_current, price2_current, price1_next, price2_next):
    # Compute initial and new price ratio
    initial_ratio = price1_current / price2_current
    new_ratio = price1_next / price2_next

    # Impermanent loss formula
    rho = new_ratio / initial_ratio  # Relative price change
    il = 2 * np.sqrt(rho) / (1 + rho) - 1

    return il

weekly_dates = df.resample('W').last().index

# Calculate weekly correlations and impermanent losses
best_pair_losses = []
average_pair_losses = []
median_pair_losses = []
loss=[]

for i in range(1, len(weekly_dates) - 1):  # Start from week 2 and end one week before the last
    # ... (Code to calculate weekly_corr as before) ...

    # Find the best pair for the previous week (i-1)
    best_pair = best_pairs[i - 1]['pair']
    all_pair_losses_current_week = []
    for coin1 in week_corr.columns:
        for coin2 in week_corr.columns:
            if coin1 != coin2:
                try:
                    price_coin1_current_week = df.loc[weekly_dates[i - 1], coin1 + '-USD'].values[0]
                    price_coin2_current_week = df.loc[weekly_dates[i - 1], coin2 + '-USD'].values[0]
                    price_coin1_next_week = df.loc[weekly_dates[i], coin1 + '-USD'].values[0]
                    price_coin2_next_week = df.loc[weekly_dates[i], coin2 + '-USD'].values[0]

                    impermanent_loss = calculate_impermanent_loss(
                        price_coin1_current_week, price_coin2_current_week,
                        price_coin1_next_week, price_coin2_next_week
                    )
                    all_pair_losses_current_week.append(impermanent_loss)

                except (KeyError, IndexError):
                    # Handle missing data or index error
                    print(f"Warning: Missing data or index error for pair ({coin1}, {coin2}) in week {i + 1}. Skipping.")

    loss.append(all_pair_losses_current_week)

    # Calculate impermanent loss for the best pair
    price_coin1_current_week = df.loc[weekly_dates[i - 1], best_pair[0] + '-USD'].values[0]
    price_coin2_current_week = df.loc[weekly_dates[i - 1], best_pair[1] + '-USD'].values[0]
    price_coin1_next_week = df.loc[weekly_dates[i], best_pair[0] + '-USD'].values[0]
    price_coin2_next_week = df.loc[weekly_dates[i], best_pair[1] + '-USD'].values[0]
    impermanent_loss_best_pair = calculate_impermanent_loss(
        price_coin1_current_week, price_coin2_current_week,
        price_coin1_next_week, price_coin2_next_week
    )
    best_pair_losses.append(impermanent_loss_best_pair)
# best_pair_losses now contains the impermanent loss for each week
# for the best pair identified in the previous week.
average_pair_losses = [np.nanmean(losses) for losses in loss]
median_pair_losses = [np.nanmedian(losses) for losses in loss]

print(best_pair_losses)

import numpy as np
import matplotlib.pyplot as plt

# ... (your existing code to calculate losses) ...
top_pair_losses=[]
# Create x-axis values (week numbers)
weeks = range(2, len(weekly_dates))  # Start from week 2
top_pair_losses=[np.nanmax(losses) for losses in loss]
# Plot the data
plt.plot(weeks, np.array(average_pair_losses)*100, label='Average Pair Loss')
plt.plot(weeks, np.array(median_pair_losses)*100, label='Median Pair Loss')
plt.plot(weeks, np.array(top_pair_losses)*100, label='Best Pair Loss')
# Adjust the x-axis to match the length of best_pair_losses[1:]
plt.plot(weeks[1:], np.array(best_pair_losses[1:])*100, label='Our Pair Loss')

# Customize the plot
plt.xlabel('Week')
plt.ylabel('Impermanent Loss in %')
plt.title('Impermanent Loss Comparison')
plt.legend()
plt.grid(True)

# Show the plot
plt.show()

print( np.mean(np.array(average_pair_losses[:-1]) < np.array(best_pair_losses[1:])) * 100)
print( np.mean(np.array(median_pair_losses[:-1]) < np.array(best_pair_losses[1:])) * 100)
print( np.mean(np.array(best_pair_losses[:-1]) < np.array(top_pair_losses[1:])) * 100)
a=np.sum(np.array(average_pair_losses[:-1]))*100
b=np.sum(np.array(best_pair_losses[1:]))*100
c=np.sum(np.array(median_pair_losses[:-1]))*100
print(a/b)
print(c/b)
print(a)
print(b)
print(c)
